'use strict';

var Module = require('node:module');
var vendor = require('./vendor.js');
var path = require('node:path');
var path$1 = require('../external/@socketsecurity/registry/lib/path');
var constants = require('./constants.js');
var utils = require('./utils.js');
var require$$9 = require('../external/@socketsecurity/registry/lib/debug');
var logger = require('../external/@socketsecurity/registry/lib/logger');
var registry = require('../external/@socketsecurity/registry');
var require$$10 = require('../external/@socketsecurity/registry/lib/objects');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
let _arboristPkgPath;
function getArboristPackagePath() {
  if (_arboristPkgPath === undefined) {
    const pkgName = '@npmcli/arborist';
    const mainPathWithForwardSlashes = path$1.normalizePath(utils.getNpmRequire().resolve(pkgName));
    const arboristPkgPathWithForwardSlashes = mainPathWithForwardSlashes.slice(0, mainPathWithForwardSlashes.lastIndexOf(pkgName) + pkgName.length);
    _arboristPkgPath = constants.WIN32 ? path.normalize(arboristPkgPathWithForwardSlashes) : arboristPkgPathWithForwardSlashes;
  }
  return _arboristPkgPath;
}
let _arboristClassPath;
function getArboristClassPath() {
  if (_arboristClassPath === undefined) {
    _arboristClassPath = path.join(getArboristPackagePath(), 'lib/arborist/index.js');
  }
  return _arboristClassPath;
}
let _arboristEdgeClassPath;
function getArboristEdgeClassPath() {
  if (_arboristEdgeClassPath === undefined) {
    _arboristEdgeClassPath = path.join(getArboristPackagePath(), 'lib/edge.js');
  }
  return _arboristEdgeClassPath;
}
let _arboristNodeClassPath;
function getArboristNodeClassPath() {
  if (_arboristNodeClassPath === undefined) {
    _arboristNodeClassPath = path.join(getArboristPackagePath(), 'lib/node.js');
  }
  return _arboristNodeClassPath;
}
let _arboristOverrideSetClassPath;
function getArboristOverrideSetClassPath() {
  if (_arboristOverrideSetClassPath === undefined) {
    _arboristOverrideSetClassPath = path.join(getArboristPackagePath(), 'lib/override-set.js');
  }
  return _arboristOverrideSetClassPath;
}

const DiffAction = utils.createEnum({
  add: 'ADD',
  change: 'CHANGE',
  remove: 'REMOVE'
});

function getUrlOrigin(input) {
  try {
    // TODO: URL.parse is available in Node 22.1.0. We can use it when we drop Node 18.
    // https://nodejs.org/docs/latest-v22.x/api/url.html#urlparseinput-base
    // return URL.parse(input)?.origin ?? ''
    return new URL(input).origin ?? '';
  } catch {}
  return '';
}
function findBestPatchVersion(node, availableVersions, options) {
  const {
    minSatisfying = false,
    vulnerableVersionRange
  } = {
    __proto__: null,
    ...options
  };
  const manifestData = registry.getManifestData('npm', node.name);
  let eligibleVersions;
  if (manifestData && manifestData.name === manifestData.package) {
    const major = utils.getMajor(manifestData.version);
    if (typeof major !== 'number') {
      return null;
    }
    eligibleVersions = availableVersions.filter(v => utils.getMajor(v) === major);
  } else {
    const major = utils.getMajor(node.version);
    if (typeof major !== 'number') {
      return null;
    }
    eligibleVersions = availableVersions.filter(v =>
    // Filter for versions that are within the current major version and
    // are NOT in the vulnerable range.
    utils.getMajor(v) === major && (!vulnerableVersionRange || !vendor.semverExports.satisfies(v, vulnerableVersionRange)));
  }
  if (eligibleVersions) {
    const satisfying = minSatisfying ? vendor.semverExports.minSatisfying : vendor.semverExports.maxSatisfying;
    return satisfying(eligibleVersions, '*');
  }
  return null;
}
function findPackageNode(tree, name, version) {
  const queue = [tree];
  const visited = new Set();
  let sentinel = 0;
  while (queue.length) {
    if (sentinel++ === constants.LOOP_SENTINEL) {
      throw new Error('Detected infinite loop in findPackageNode');
    }
    const nodeOrLink = queue.pop();
    const node = getTargetNode(nodeOrLink);
    if (visited.has(node)) {
      continue;
    }
    visited.add(node);
    if (node.name === name && (typeof version !== 'string' || node.version === version)) {
      return node;
    }
    for (const child of node.children.values()) {
      queue.push(child);
    }
    for (const edge of node.edgesOut.values()) {
      const {
        to
      } = edge;
      if (to) {
        queue.push(to);
      }
    }
  }
  return undefined;
}
function findPackageNodes(tree, name, version) {
  const matches = [];
  const queue = [tree];
  const visited = new Set();
  let sentinel = 0;
  while (queue.length) {
    if (sentinel++ === constants.LOOP_SENTINEL) {
      throw new Error('Detected infinite loop in findPackageNodes');
    }
    const nodeOrLink = queue.pop();
    const node = getTargetNode(nodeOrLink);
    if (visited.has(node)) {
      continue;
    }
    visited.add(node);
    const {
      version: targetVersion
    } = node;
    if (!targetVersion && Array.isArray(node.errors) && node.errors.length) {
      require$$9.debugFn('notice', `miss: version for ${node.name} due to errors:\n`, node.errors);
    }
    if (node.name === name && ("undefined" !== 'string')) {
      matches.push(node);
    }
    for (const child of node.children.values()) {
      queue.push(child);
    }
    for (const edge of node.edgesOut.values()) {
      const {
        to
      } = edge;
      if (to) {
        queue.push(to);
      }
    }
  }
  return matches;
}
async function getAlertsMapFromArborist(arb, options) {
  const opts = {
    __proto__: null,
    consolidate: false,
    nothrow: false,
    ...options,
    filter: utils.toFilterConfig(require$$10.getOwn(options, 'filter'))
  };
  const needInfoOn = getDetailsFromDiff(arb.diff, {
    filter: {
      existing: opts.filter.existing
    }
  });
  const purls = needInfoOn.map(d => utils.idToNpmPurl(d.node.pkgid));
  let overrides;
  const overridesMap = (arb.actualTree ?? arb.idealTree ?? (await arb.loadActual()))?.overrides?.children;
  if (overridesMap) {
    overrides = Object.fromEntries(Array.from(overridesMap.entries()).map(([key, overrideSet]) => {
      return [key, overrideSet.value];
    }));
  }
  return await utils.getAlertsMapFromPurls(purls, {
    overrides,
    ...opts
  });
}
function getDetailsFromDiff(diff, options) {
  const details = [];
  // `diff` is `null` when `npm install --package-lock-only` is passed.
  if (!diff) {
    require$$9.debugFn('notice', `miss: diff is ${diff}`);
    return details;
  }
  const {
    NPM_REGISTRY_URL
  } = constants;
  const filterConfig = utils.toFilterConfig({
    existing: false,
    unknownOrigin: true,
    ...require$$10.getOwn(options, 'filter')
  });
  const queue = [...diff.children];
  let pos = 0;
  let {
    length: queueLength
  } = queue;
  while (pos < queueLength) {
    if (pos === constants.LOOP_SENTINEL) {
      throw new Error('Detected infinite loop while walking Arborist diff');
    }
    const currDiff = queue[pos++];
    const {
      action
    } = currDiff;
    if (action) {
      // The `pkgNode`, i.e. the `ideal` node, will be `undefined` if the diff
      // action is 'REMOVE'
      // The `oldNode`, i.e. the `actual` node, will be `undefined` if the diff
      // action is 'ADD'.
      const {
        actual: oldNode,
        ideal: pkgNode
      } = currDiff;
      let existing;
      let keep = false;
      if (action === DiffAction.change) {
        if (pkgNode?.package.version !== oldNode?.package.version) {
          keep = true;
          if (oldNode?.package.name && oldNode.package.name === pkgNode?.package.name) {
            existing = oldNode;
          }
        }
      } else {
        keep = action !== DiffAction.remove;
      }
      if (keep && pkgNode?.resolved && (!oldNode || oldNode.resolved)) {
        if (filterConfig.unknownOrigin || getUrlOrigin(pkgNode.resolved) === NPM_REGISTRY_URL) {
          details.push({
            node: pkgNode,
            existing
          });
        }
      }
    }
    for (const child of currDiff.children) {
      queue[queueLength++] = child;
    }
  }
  if (filterConfig.existing) {
    const {
      unchanged
    } = diff;
    for (let i = 0, {
        length
      } = unchanged; i < length; i += 1) {
      const pkgNode = unchanged[i];
      if (filterConfig.unknownOrigin || getUrlOrigin(pkgNode.resolved) === NPM_REGISTRY_URL) {
        details.push({
          node: pkgNode,
          existing: pkgNode
        });
      }
    }
  }
  return details;
}
function getTargetNode(nodeOrLink) {
  return nodeOrLink?.isLink ? nodeOrLink.target : nodeOrLink ?? null;
}
function isTopLevel(tree, node) {
  return getTargetNode(tree.children.get(node.name)) === node;
}
function updateNode(node, newVersion, newVersionPackument) {
  // Object.defineProperty is needed to set the version property and replace
  // the old value with newVersion.
  Object.defineProperty(node, 'version', {
    configurable: true,
    enumerable: true,
    get: () => newVersion
  });
  // Update package.version associated with the node.
  node.package.version = newVersion;
  // Update node.resolved.
  const purlObj = vendor.packageurlJsExports.PackageURL.fromString(utils.idToNpmPurl(node.name));
  node.resolved = `${constants.NPM_REGISTRY_URL}/${node.name}/-/${purlObj.name}-${newVersion}.tgz`;
  // Update node.integrity with the targetPackument.dist.integrity value if available
  // else delete node.integrity so a new value is resolved for the target version.
  const {
    integrity
  } = newVersionPackument.dist;
  if (integrity) {
    node.integrity = integrity;
  } else {
    delete node.integrity;
  }
  // Update node.package.deprecated based on targetPackument.deprecated.
  if (require$$10.hasOwn(newVersionPackument, 'deprecated')) {
    node.package['deprecated'] = newVersionPackument.deprecated;
  } else {
    delete node.package['deprecated'];
  }
  // Update node.package.dependencies.
  const newDeps = {
    ...newVersionPackument.dependencies
  };
  const {
    dependencies: oldDeps
  } = node.package;
  node.package.dependencies = newDeps;
  if (oldDeps) {
    for (const oldDepName of Object.keys(oldDeps)) {
      if (!require$$10.hasOwn(newDeps, oldDepName)) {
        // Detach old edges for dependencies that don't exist on the updated
        // node.package.dependencies.
        node.edgesOut.get(oldDepName)?.detach();
      }
    }
  }
  for (const newDepName of Object.keys(newDeps)) {
    if (!require$$10.hasOwn(oldDeps, newDepName)) {
      // Add new edges for dependencies that don't exist on the old
      // node.package.dependencies.
      node.addEdgeOut(new Edge({
        from: node,
        name: newDepName,
        spec: newDeps[newDepName],
        type: 'prod'
      }));
    }
  }
}
function updatePackageJsonFromNode(editablePkgJson, tree, node, newVersion, rangeStyle) {
  let result = false;
  if (!isTopLevel(tree, node)) {
    return result;
  }
  const {
    name
  } = node;
  for (const depField of ['dependencies', 'optionalDependencies', 'peerDependencies']) {
    const depObject = editablePkgJson.content[depField];
    const depValue = require$$10.hasOwn(depObject, name) ? depObject[name] : undefined;
    if (typeof depValue !== 'string' || depValue.startsWith('catalog:')) {
      continue;
    }
    let oldRange = depValue;
    // Use npa if depValue looks like more than just a semver range.
    if (depValue.includes(':')) {
      const npaResult = utils.npa(depValue);
      if (!npaResult || npaResult.subSpec) {
        continue;
      }
      oldRange = npaResult.rawSpec;
    }
    const oldMin = utils.getMinVersion(oldRange);
    const newRange = oldMin &&
    // Ensure we're on the same major version...
    utils.getMajor(newVersion) === oldMin.major &&
    // and not a downgrade.
    vendor.semverExports.gte(newVersion, oldMin.version) ? utils.applyRange(oldRange, newVersion, rangeStyle) : oldRange;
    if (oldRange !== newRange) {
      result = true;
      editablePkgJson.update({
        [depField]: {
          ...depObject,
          [name]: newRange
        }
      });
    }
  }
  return result;
}

// @ts-ignore
const {
  kInternalsSymbol,
  [kInternalsSymbol]: {
    getIpc
  }
} = constants;
const SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {
  __proto__: null,
  audit: false,
  dryRun: true,
  fund: false,
  ignoreScripts: true,
  progress: false,
  save: false,
  saveBundle: false,
  silent: true
};
const SAFE_WITH_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {
  // @ts-ignore
  __proto__: null,
  ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,
  dryRun: false,
  save: true
};
const kCtorArgs = Symbol('ctorArgs');
const kRiskyReify = Symbol('riskyReify');
const Arborist = vendor.arboristExports;

// Implementation code not related to our custom behavior is based on
// https://github.com/npm/cli/blob/v11.0.0/workspaces/arborist/lib/arborist/index.js:
class SafeArborist extends Arborist {
  constructor(...ctorArgs) {
    super({
      path: (ctorArgs.length ? ctorArgs[0]?.path : undefined) ?? process.cwd(),
      ...(ctorArgs.length ? ctorArgs[0] : undefined),
      ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES
    }, ...ctorArgs.slice(1));
    this[kCtorArgs] = ctorArgs;
  }
  async [kRiskyReify](...args) {
    const ctorArgs = this[kCtorArgs];
    const arb = new Arborist({
      ...(ctorArgs.length ? ctorArgs[0] : undefined),
      progress: false
    }, ...ctorArgs.slice(1));
    const ret = await arb.reify({
      ...(args.length ? args[0] : undefined),
      progress: false
    }, ...args.slice(1));
    Object.assign(this, arb);
    return ret;
  }

  // @ts-ignore Incorrectly typed.
  async reify(...args) {
    const options = {
      __proto__: null,
      ...(args.length ? args[0] : undefined)
    };
    const ipc = await getIpc();
    require$$9.debugDir('inspect', {
      ipc
    });
    const binName = ipc[constants.SOCKET_CLI_SHADOW_BIN];
    if (!binName) {
      return await this[kRiskyReify](...args);
    }
    await super.reify({
      ...options,
      ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,
      progress: false
    },
    // @ts-ignore: TypeScript gets grumpy about rest parameters.
    ...args.slice(1));
    const shadowAcceptRisks = ipc[constants.SOCKET_CLI_SHADOW_ACCEPT_RISKS];
    const shadowProgress = ipc[constants.SOCKET_CLI_SHADOW_PROGRESS];
    const shadowSilent = ipc[constants.SOCKET_CLI_SHADOW_SILENT];
    const acceptRisks = shadowAcceptRisks || constants.ENV.SOCKET_CLI_ACCEPT_RISKS;
    const silent = !!options['silent'];
    const spinner = silent || !shadowProgress ? undefined : constants.spinner;
    const isShadowNpx = binName === 'npx';
    const alertsMap = await getAlertsMapFromArborist(this, {
      apiToken: ipc[constants.SOCKET_CLI_SHADOW_API_TOKEN],
      spinner,
      filter: acceptRisks || options.dryRun || options['yes'] ? {
        actions: ['error'],
        blocked: true,
        existing: true
      } : {
        actions: ['error', 'monitor', 'warn'],
        existing: isShadowNpx
      }
    });
    if (alertsMap.size) {
      process.exitCode = 1;
      const viewAllRisks = constants.ENV.SOCKET_CLI_VIEW_ALL_RISKS;
      utils.logAlertsMap(alertsMap, {
        hideAt: viewAllRisks ? 'none' : 'middle',
        output: process.stderr
      });
      throw new Error(`
          Socket ${binName} exiting due to risks.${viewAllRisks ? '' : `\nView all risks - Rerun with environment variable ${constants.SOCKET_CLI_VIEW_ALL_RISKS}=1.`}${acceptRisks ? '' : `\nAccept risks - Rerun with environment variable ${constants.SOCKET_CLI_ACCEPT_RISKS}=1.`}
        `.trim());
    } else if (!silent && !shadowSilent) {
      logger.logger.success(`Socket ${binName} ${acceptRisks ? 'accepted' : 'found no'} risks`);
      if (isShadowNpx) {
        logger.logger.log(`Running ${options.add[0]}`);
      }
    }
    return await this[kRiskyReify](...args);
  }
}

const require$1 = Module.createRequire(require('node:url').pathToFileURL(__filename).href);
const Edge = vendor.edgeExports;
const Node = vendor.nodeExports;
const OverrideSet = vendor.overrideSetExports;
function installSafeArborist() {
  // Override '@npmcli/arborist' module exports with patched variants based on
  // https://github.com/npm/cli/pull/8089.
  const cache = require$1.cache;
  cache[getArboristClassPath()] = {
    exports: SafeArborist
  };
  cache[getArboristEdgeClassPath()] = {
    exports: Edge
  };
  cache[getArboristNodeClassPath()] = {
    exports: Node
  };
  cache[getArboristOverrideSetClassPath()] = {
    exports: OverrideSet
  };
}

installSafeArborist();

exports.Arborist = Arborist;
exports.SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES;
exports.SAFE_WITH_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = SAFE_WITH_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES;
exports.findBestPatchVersion = findBestPatchVersion;
exports.findPackageNode = findPackageNode;
exports.findPackageNodes = findPackageNodes;
exports.getAlertsMapFromArborist = getAlertsMapFromArborist;
exports.updateNode = updateNode;
exports.updatePackageJsonFromNode = updatePackageJsonFromNode;
//# debugId=ef09cd0e-acf2-43e3-8f8e-3dff17a3741b
//# sourceMappingURL=shadow-npm-inject.js.map
